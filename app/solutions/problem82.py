'''
Path sum: three ways

the same dynamic programming idea as problem 81.

    move strategy: if a node is generated by moving upward, it can only generate next node by 
    moving upward or rightward, not downward. The same applies to moving downward.


260324
'''

SMALL_MATRIX = ['131,673,234,103,18','201,96,342,965,150','630,803,746,422,111','537,699,497,121,956','805,732,524,37,331']


def makeMatrix(lines):
    matrix = []
    for line in lines:
        matrix.append([int(x) for x in line.strip().split(',')])
    return matrix


def updateDistanceMatrix(prevNode, node, distanceMatrix, matrix):
    dist = distanceMatrix[prevNode[0]][prevNode[1]] + matrix[node[0]][node[1]]
    if distanceMatrix[node[0]][node[1]] == 0 or dist < distanceMatrix[node[0]][node[1]]:
        distanceMatrix[node[0]][node[1]] = dist

import sys
def findMinNodeInFrontLine(frontLine, distanceMatrix):
    minDist = sys.maxint
    minNode = (0, 0)
    for node in frontLine:
        if distanceMatrix[node[0]][node[1]] < minDist:
            minDist = distanceMatrix[node[0]][node[1]]
            minNode = (node[0], node[1])
    return minNode

def printMatrix(matrix):
    for i in range(len(matrix)):
        print(matrix[i])
        print('')

def extendUpward(node, dim):
    return None if node[0] == 0 or node[2] == 1 else (node[0]-1, node[1], -1)

def extendDownward(node, dim):
    return None if node[0] == dim-1 or node[2] == -1 else (node[0]+1, node[1], 1)

def extendRightward(node, dim):
    return None if node[1] == dim-1 else (node[0], node[1]+1, 0)

def solution():
    # matrix = makeMatrix(SMALL_MATRIX)
    matrix = makeMatrix(open('problem82.txt'))
    dim = len(matrix)
    distanceMatrix = [[0] * dim for i in range(dim)]
    for i in range(dim):
        distanceMatrix[i][0] = matrix[i][0]

    # each node (col, row, move_direction)
    # -1 upward, 1 downward, 0 rightward
    frontLine = [(y, 0, 0) for y in range(dim)]

    while len(frontLine) > 0:
        # print(frontLine)
        print(len(frontLine))
        newFrontLine = []
        for node in frontLine:
            # extend upward
            newNode = extendUpward(node, dim)
            if newNode is not None:
                updateDistanceMatrix(node, newNode, distanceMatrix, matrix)
                if newNode not in newFrontLine and newNode[1] != dim-1:
                    newFrontLine.append(newNode)
            # extend rightward
            newNode = extendRightward(node, dim)
            if newNode is not None:
                updateDistanceMatrix(node, newNode, distanceMatrix, matrix)
                if newNode not in newFrontLine and newNode[1] != dim-1:
                    newFrontLine.append(newNode)
            # extend downward
            newNode = extendDownward(node, dim)
            if newNode is not None:
                updateDistanceMatrix(node, newNode, distanceMatrix, matrix)
                if newNode not in newFrontLine and newNode[1] != dim-1:
                    newFrontLine.append(newNode)
        # printMatrix(distanceMatrix)
        # print('========')
        # prone
        if len(newFrontLine) > 2000:
            sorted(newFrontLine, key=lambda node: distanceMatrix[node[0]][node[1]])
            frontLine = newFrontLine[:len(newFrontLine)/2]
        else:
            frontLine = newFrontLine
    return min([distanceMatrix[x][dim-1] for x in range(dim)])


if __name__ == '__main__':
    print('Result', solution())
